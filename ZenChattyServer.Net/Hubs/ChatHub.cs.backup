using System.Security.Claims;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.SignalR;
using Microsoft.EntityFrameworkCore;
using ZenChattyServer.Net.Helpers;
using ZenChattyServer.Net.Helpers.Context;
using ZenChattyServer.Net.Models;
using ZenChattyServer.Net.Models.Enums;
using ZenChattyServer.Net.Models.Request;
using ZenChattyServer.Net.Models.Response;
using ZenChattyServer.Net.Services;
using ZenChattyServer.Net.Models.Events;

namespace ZenChattyServer.Net.Hubs;

/// <summary>
/// 聊天中心Hub，负责实时消息推送和聊天组管理
/// </summary>
// [Authorize]  // 临时禁用以调试连接问题
public class ChatHub(
    // UserRelatedContext context,
    // MessageValidationService validationService,
    // IMessageQueueService messageQueueService,  // 临时移除 RabbitMQ 依赖
    // ContactService contactService,
    ILogger<ChatHub> logger)
    : Hub
{
    #region 私有字段和属性
    
    /// <summary>
    /// 跟踪每个聊天组的需要获取特定聊天实时消息的用户连接
    /// </summary>
    private Dictionary<string, HashSet<(Guid userId, string connection)>> _chatGroupConnections = new();
    
    #endregion
    
    // 构造函数完成后记录日志
    private bool _initialized = LogInitialization(logger);
    
    private static bool LogInitialization(ILogger<ChatHub> logger)
    {
        logger.LogInformation("ChatHub 实例已创建");
        return true;
    }
    
    #region 连接与断开连接管理
    
    /// <summary>
    /// 客户端连接时调用
    /// </summary>
    public override async Task OnConnectedAsync()
    {
        var userId = GetCurrentUserId();
        if (userId.HasValue)
        {
            logger.LogInformation("用户 {UserId} 已连接到聊天中心，连接ID: {ConnectionId}", userId, Context.ConnectionId);
        }

        await base.OnConnectedAsync();
    }

    /// <summary>
    /// 客户端断开连接时调用
    /// </summary>
    public override async Task OnDisconnectedAsync(Exception? exception)
    {
        var userId = GetCurrentUserId();
        if (userId.HasValue)
        {
            logger.LogInformation("用户 {UserId} 已断开连接，连接ID: {ConnectionId}", userId, Context.ConnectionId);
        }

        await base.OnDisconnectedAsync(exception);
    }
    
    #endregion
    
    #region 客户端事件
    
    /// <summary>
    /// 客户端事件：加入聊天组
    /// 用于实时获取IncomeMessage和PatchMessage事件
    /// </summary>
    public Task JoinChat(string chatUniqueMark)
    {
        Console.WriteLine($"========== JoinChat 被调用！chatUniqueMark={chatUniqueMark} ==========");
        logger.LogInformation("========== JoinChat 被调用！chatUniqueMark={ChatId} ==========", chatUniqueMark);
        
        try
        {
            Console.WriteLine($"ConnectionId: {Context.ConnectionId}");
            
            // 最简单的实现：直接加入SignalR组
            Groups.AddToGroupAsync(Context.ConnectionId, chatUniqueMark).Wait();
            
            Console.WriteLine($"成功加入聊天组: {chatUniqueMark}");
            logger.LogInformation("成功加入聊天组: {ChatId}", chatUniqueMark);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"JoinChat 异常: {ex.Message}\n{ex.StackTrace}");
            logger.LogError(ex, "加入聊天组时发生错误，聊天: {ChatId}", chatUniqueMark);
        }
        
        return Task.CompletedTask;
    }

    /// <summary>
    /// 客户端事件：离开聊天组
    /// 在Hub发现断开网络连接或在客户端上退出聊天界面的时候调用
    /// </summary>
    public Task LeaveChat(string chatUniqueMark)
    {
        Console.WriteLine($"========== LeaveChat 被调用！chatUniqueMark={chatUniqueMark} ==========");
        
        try
        {
            // 最简单的实现：直接离开SignalR组
            Groups.RemoveFromGroupAsync(Context.ConnectionId, chatUniqueMark).Wait();
            
            Console.WriteLine($"成功离开聊天组: {chatUniqueMark}");
            logger.LogInformation("成功离开聊天组: {ChatId}", chatUniqueMark);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"LeaveChat 异常: {ex.Message}");
            logger.LogError(ex, "离开聊天组时发生错误，聊天: {ChatId}", chatUniqueMark);
        }
        
        return Task.CompletedTask;
    }

    /* 临时注释以测试 JoinChat
    /// <summary>
    /// 客户端事件：发送消息
    /// 任何时候都可使用，用于向服务端发送一条消息
    /// </summary>
    public async Task<SendMessageResponse> SendMessage(SendMessageRequest request) //, bool ignoreAuth = false)
    {
        var userId = GetCurrentUserId();
        if (!userId.HasValue)
            return SendMessageResponse.Unauthorized("用户未认证");

        try
        {
            // 1. 验证消息内容
            var contentValidation = validationService.ValidateMessageContent(request.Content);
            if (contentValidation.ResultCanBe != EMessageSendResult.Success)
                return contentValidation;

            // 2. 确定聊天类型并验证权限
            var chat = await context.Chats
                .Include(c => c.Contacts)
                .FirstOrDefaultAsync(c => c.UniqueMark == request.ChatUniqueMark);

            if (chat == null)
                return SendMessageResponse.ChatNotFound();

            SendMessageResponse validationResult;
            
            // 检查是否为私聊
            var privateChat = await context.PrivateChats
                .FirstOrDefaultAsync(pc => pc.UniqueMark == request.ChatUniqueMark);
                
            if (privateChat != null)
            {
                // 私聊验证
                validationResult = await validationService.ValidatePrivateChatMessageAsync(
                    request.ChatUniqueMark, userId.Value, request.ViaGroupChatId);
            }
            else
            {
                // 群聊验证
                validationResult = await validationService.ValidateGroupChatMessageAsync(
                    request.ChatUniqueMark, userId.Value);
            }

            if (validationResult.ResultCanBe != EMessageSendResult.Success)
                return validationResult;

            // 3. 创建消息对象
            var sender = await context.Users.FindAsync(userId.Value);
            
            if (sender == null)
                return SendMessageResponse.InternalError("发送者或聊天不存在");

            var message = new Message(sender, chat, request.Content)
            {
                TraceId = Guid.NewGuid().ToString(),
                Type = request.MessageType,
                SentTimestamp = request.SentTimestamp,
                ServerCaughtTimestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(),
                Info = request.Info ?? "",
                IsMentioningAll = request.IsMentioningAll,
                MentionedUserGuids = request.MentionedUserIds?.Select(id => id.ToString()).ToArray()
            };

            // 4. 将消息发送到消息队列
            await messageQueueService.SendMessageAsync(message);

            // 5. 增加聊天中所有联系人的未读计数（排除发送者自己）
            await contactService.IncreaseUnreadCountAsync(request.ChatUniqueMark, userId.Value);

            // 6. 根据用户是否在聊天组决定推送方式
            await DistributeMessageAsync(request.ChatUniqueMark, message, userId.Value);

            logger.LogInformation("用户 {UserId} 在聊天 {ChatId} 发送消息，消息ID: {MessageId}", 
                userId, request.ChatUniqueMark, message.TraceId);

            return SendMessageResponse.Success(new Guid(message.TraceId));
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "发送消息时发生错误，用户: {UserId}, 聊天: {ChatId}", 
                userId, request.ChatUniqueMark);
            return SendMessageResponse.InternalError(ex.Message);
        }
    }

    /// <summary>
    /// 客户端事件：更新消息
    /// 任何时候都可使用，用于向服务端发送一条已有的消息
    /// 仅允许更新isCanceled为false的消息，更新isCanceled为true或更改其isAnnouncement为true/false
    /// </summary>
    public async Task<UpdateMessageResponse> UpdateMessage(UpdateMessageRequest request) // todo next-step 可以优化为分操作来dispatch
    {
        var userId = GetCurrentUserId();
        if (!userId.HasValue)
            return UpdateMessageResponse.Unauthorized("用户未认证");

        try
        {
            // 1. 验证消息存在且属于当前用户
            var message = await context.Messages
                .Include(m => m.OfChat)
                .FirstOrDefaultAsync(m => m.TraceId == request.MessageTraceId && m.OfChat.UniqueMark == request.ChatUniqueMark);

            if (message == null)
                return UpdateMessageResponse.MessageNotFound();

            // 3. 验证消息状态（仅允许更新isCanceled为false的消息）
            if (message.IsCanceled)
                return UpdateMessageResponse.InvalidOperation("无法更新已取消的消息");
            
            // 2. 验证用户是否有权限更新此消息
            // check if is group chat
            if (message.SenderId != userId.Value) // optimizable: group chat
            {
                var tryGetGroup = (await context.GroupChats.FirstOrDefaultAsync(gc => gc.UniqueMark == request.ChatUniqueMark)) ;
                var isGroup = tryGetGroup is not null;
                
                if (!isGroup || !RelationshipHelper.IsUserGroupMate(message.SenderId, userId.Value, tryGetGroup!))
                    return UpdateMessageResponse.Unauthorized("无权更新此消息");
                
                GroupChatMember? gm1 = context.GroupChatMembers.FirstOrDefault(gcm => gcm.TheGuyId == message.SenderId && gcm.GroupChatId == request.ChatUniqueMark),
                    gm2 = context.GroupChatMembers.FirstOrDefault(gcm => gcm.TheGuyId == userId.Value && gcm.GroupChatId == request.ChatUniqueMark);
                
                if (!(gm1 is not null && gm2 is not null && AuthHelper.CanOperateMember(gm1, gm2)))
                    return UpdateMessageResponse.Unauthorized("无权更新此消息");
            }

            // 4. 验证更新内容
            if (string.IsNullOrWhiteSpace(request.NewContent))
                return UpdateMessageResponse.InvalidContent("消息内容不能为空");

            // 5. 更新消息内容
            var originalContent = message.Content;
            message.Content = request.NewContent;
            message.ServerCaughtTimestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();

            context.Messages.Update(message);
            await context.SaveChangesAsync();

            // 6. 消息更新仅在用户接收消息时推送，故仅更新在已在聊天组的用户消息
            await PatchMessage(request.ChatUniqueMark, message);
            // await DistributeMessageUpdateAsync(request.ChatUniqueMark, message, userId.Value);

            logger.LogInformation("用户 {UserId} 更新聊天 {ChatId} 中的消息 {MessageId}，原内容: {OriginalContent}, 新内容: {NewContent}", 
                userId, request.ChatUniqueMark, message.TraceId, originalContent, request.NewContent);

            return UpdateMessageResponse.Success();
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "更新消息时发生错误，用户: {UserId}, 聊天: {ChatId}, 消息: {MessageId}", 
                userId, request.ChatUniqueMark, request.MessageTraceId);
            return UpdateMessageResponse.InternalError(ex.Message);
        }
    }
    
    /// <summary>
    /// 标记消息已读（客户端调用）
    /// </summary>
    public async Task MarkMessagesAsRead(string chatUniqueMark)
    {
        var userId = GetCurrentUserId();
        if (userId is null || string.IsNullOrEmpty(userId.ToString()) || userId.ToString() == Guid.Empty.ToString()) return;
        // #1 i even did so much
        try
        {
            // 重置该聊天的未读计数
            await contactService.ResetUnreadCountAsync(userId.Value, chatUniqueMark);

            // 获取更新后的Contact对象
            var contact = await context.Contacts
                .Include(c => c.Object)
                .FirstOrDefaultAsync(c => c.Object.UniqueMark == chatUniqueMark && c.HostId == userId.Value);

            if (contact != null)
            {
                // 获取该用户的总未读计数 todo ?
                // var totalUnreadCount = await contactService.GetTotalUnreadCountAsync(userId.Value);
                contact.LastUsed = DateTime.UtcNow;
                context.Contacts.Update(contact);
                await context.SaveChangesAsync();
                
                // todo maynotpercfect 或许当前的用户映射会导致多客户端问题。事实上放弃多客户端适配。
                await Clients.User(userId.ToString()).SendAsync("UpdateRecents");
                // why this warning it can be null??? #1
            }

            logger.LogInformation("用户 {UserId} 标记聊天 {ChatId} 消息已读", userId, chatUniqueMark);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "标记消息已读失败，用户: {UserId}, 聊天: {ChatId}", userId, chatUniqueMark);
        }
    }
    
    #endregion
    
    #region 服务器端事件
    
    /// <summary>
    /// 服务器端事件：IncomeMessage
    /// 向所有组内用户发送一个消息对象，用于推送一条新消息
    /// </summary>
    private async Task IncomeMessage(string chatUniqueMark, Message message)
    {
        try
        {
            if (_chatGroupConnections.TryGetValue(chatUniqueMark, out var connections))
            {
                var eventData = new IncomeMessageEvent(chatUniqueMark, message);
                await Clients.Clients(PickConnectionIdsOnly(connections.ToList())).SendAsync("IncomeMessage", eventData);
                
                logger.LogInformation("向聊天组 {ChatId} 推送新消息 {MessageId}，影响需要获取特定聊天实时消息的用户数: {UserCount}", 
                    chatUniqueMark, message.TraceId, connections.Count);
            }
            else
            {
                logger.LogWarning("聊天组 {ChatId} 没有需要获取特定聊天实时消息的用户，跳过IncomeMessage推送", chatUniqueMark);
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "推送IncomeMessage失败，聊天: {ChatId}, 消息: {MessageId}", 
                chatUniqueMark, message.TraceId);
        }
    }

    /// <summary>
    /// 服务器端事件：PatchMessage
    /// 向所有组内用户发送一个消息对象，用于更新一条已有消息的内容和状态
    /// </summary>
    private async Task PatchMessage(string chatUniqueMark, Message updatedMessage, string updateType = "content")
    {
        try
        {
            if (_chatGroupConnections.TryGetValue(chatUniqueMark, out var connections))
            {
                var eventData = new PatchMessageEvent(chatUniqueMark, updatedMessage, updateType);
                await Clients.Clients(PickConnectionIdsOnly(connections.ToList())).SendAsync("PatchMessage", eventData);
                
                logger.LogInformation("向聊天组 {ChatId} 推送消息更新 {MessageId}，更新类型: {UpdateType}，影响需要获取特定聊天实时消息的用户数: {UserCount}", 
                    chatUniqueMark, updatedMessage.TraceId, updateType, connections.Count);
            }
            else
            {
                logger.LogWarning("聊天组 {ChatId} 没有需要获取特定聊天实时消息的用户，跳过PatchMessage推送", chatUniqueMark);
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "推送PatchMessage失败，聊天: {ChatId}, 消息: {MessageId}", 
                chatUniqueMark, updatedMessage.TraceId);
        }
    }

    /// <summary>
    /// 服务器端事件：UpdateRecents
    /// 向所有不在组内但是订阅了消息更新（持有对应有效Contact的用户）在订阅的聊天发生更新的时候，通知客户端拉取新的最近消息
    /// </summary>
    private async Task UpdateRecents(string chatUniqueMark, Message message) // Send UpdateRecentsEvent
    {
        try
        {
            var subs = await GetOthers(chatUniqueMark, message);

            if (subs.others.Count > 0)
            {
                // 获取最新的未读计数
                var latestContact = await context.Contacts
                    .FirstOrDefaultAsync(c => c.Object.UniqueMark == chatUniqueMark);
                
                // 向所有不需要特定聊天实时消息的用户推送UpdateRecents事件
                foreach (var userId in subs.others)
                {
                    await Clients.User(userId.ToString()).SendAsync("UpdateRecents");
                }
                
                logger.LogInformation("向 {OfflineUserCount} 个不需要特定聊天实时消息的用户推送UpdateRecents事件，聊天: {ChatId}", 
                    subs.others.Count, chatUniqueMark);
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "推送UpdateRecents失败，聊天: {ChatId}", chatUniqueMark);
        }
    }
    
    #endregion
    
    #region 系统内部方法
    
    /// <summary>
    /// 模拟用户发送消息（系统内部调用）
    /// 保留系统内部调用的SendAsUser方法
    /// </summary>
    public async Task SendMessageAsUser( // todo 先不合并了，烦
        string chatUniqueMark, 
        Guid senderId, 
        string content, 
        EMessageType messageType = EMessageType.Normal
    ) 
    {
        try
        {
            // 1. 验证聊天存在
            var chat = await context.Chats
                .Include(c => c.Contacts)
                .FirstOrDefaultAsync(c => c.UniqueMark == chatUniqueMark);

            if (chat == null)
            {
                logger.LogWarning("模拟发送消息失败：聊天 {ChatId} 不存在", chatUniqueMark);
                return;
            }

            // 2. 验证发送者存在且是聊天成员
            var sender = await context.Users.FindAsync(senderId);
            if (sender == null)
            {
                logger.LogWarning("模拟发送消息失败：发送者 {SenderId} 不存在", senderId);
                return;
            }

            var isMember = await context.Contacts
                .AnyAsync(c => c.ObjectId == chat.UniqueMark && c.HostId == senderId);
        
            if (!isMember)
            {
                logger.LogWarning("模拟发送消息失败：用户 {SenderId} 不是聊天 {ChatId} 的成员", senderId, chatUniqueMark);
                return;
            }

            // 3. 创建消息对象
            var message = new Message(sender, chat, content)
            {
                TraceId = Guid.NewGuid().ToString(),
                Type = messageType,
                SentTimestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(),
                ServerCaughtTimestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(),
                Info = "",
                IsMentioningAll = false,
                MentionedUserGuids = null
            };

            // 4. 将消息发送到消息队列
            await messageQueueService.SendMessageAsync(message);

            // 5. 增加聊天中所有联系人的未读计数（排除发送者自己）
            await contactService.IncreaseUnreadCountAsync(chatUniqueMark, senderId);

            // 6. 根据用户是否在聊天组决定推送方式
            await DistributeMessageAsync(chatUniqueMark, message, senderId);

            logger.LogInformation("模拟用户 {SenderId} 在聊天 {ChatId} 发送消息，消息ID: {MessageId}", 
                senderId, chatUniqueMark, message.TraceId);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "模拟发送消息时发生错误，发送者: {SenderId}, 聊天: {ChatId}", 
                senderId, chatUniqueMark);
        }
    }
    
    #endregion
    
    #region 消息分发
    
    /// <summary>
    /// 分发新消息：根据用户是否在聊天组决定推送方式
    /// </summary>
    private async Task DistributeMessageAsync(string chatUniqueMark, Message message, Guid senderId)
    {
        // 向需要获取特定聊天实时消息的用户推送IncomeMessage
        await IncomeMessage(chatUniqueMark, message);
        
        // 向不需要特定聊天实时消息的用户推送UpdateRecents
        await UpdateRecents(chatUniqueMark, message); // 由于
    }
    
    #endregion
    
    #region 聊天组管理 内部
    
    /// <summary>
    /// 加入聊天组
    /// </summary>
    private async Task JoinChatGroupInternal(string chatUniqueMark, Guid userId, string connectionId)
    {
        if (!_chatGroupConnections.ContainsKey(chatUniqueMark))
        {
            _chatGroupConnections[chatUniqueMark] = [];
        }
        
        _chatGroupConnections[chatUniqueMark].Add((userId, connectionId));
        await Groups.AddToGroupAsync(connectionId, chatUniqueMark);
    }

    /// <summary>
    /// 离开聊天组
    /// </summary>
    private async Task LeaveChatGroupInternal(string chatUniqueMark, Guid userId, string connectionId)
    {
        if (_chatGroupConnections.TryGetValue(chatUniqueMark, out var connections))
        {
            connections.Remove((userId, connectionId));
            if (connections.Count == 0)
            {
                _chatGroupConnections.Remove(chatUniqueMark);
            }
        }
        
        await Groups.RemoveFromGroupAsync(connectionId, chatUniqueMark);
    }

    /// <summary>
    /// 检查用户是否在聊天组中
    /// </summary>
    private bool IsUserInChatGroup(string chatUniqueMark, Guid userId)
    {
        return _chatGroupConnections.TryGetValue(chatUniqueMark, out var connections) &&
               connections.Any(c => c.userId == userId && !string.IsNullOrEmpty(c.connection)); // value来自dict，
    }
    
    #endregion
    
    #region 辅助方法

    private static List<string> PickConnectionIdsOnly(List<(Guid userId, string connection)> raw)
    {
        return raw.Select(item => item.connection).ToList();
    }
    
    /// <summary>
    /// 获取当前用户ID
    /// </summary>
    private Guid? GetCurrentUserId()
    {
        var userIdClaim = Context.User?.FindFirst(ClaimTypes.NameIdentifier);
        if (userIdClaim != null && Guid.TryParse(userIdClaim.Value, out var userId))
        {
            return userId;
        }
        return null;
    }
    
    private async Task<(List<Guid> others, List<Contact> contacts)> GetOthers(string chatUniqueMark, Message message)
    {
        // 获取所有订阅该聊天的用户（排除发送者自己）
        var contacts = await context.Contacts
            .Include(c => c.Object)
            .Where(c => c.Object.UniqueMark == chatUniqueMark && 
                        c.HostId != message.SenderId && 
                        !c.IsBlocked)
            .ToListAsync();

        // 过滤掉已经在聊天组中的用户
        var others = contacts
            .Where(c => !IsUserInChatGroup(chatUniqueMark, c.HostId))
            .Select(c => c.HostId)
            .Distinct()
            .ToList();
        
        return (others, contacts);
    }
    
    #endregion
}